import{once as t}from"node:events";import{rm as e,symlink as n}from"node:fs/promises";import{cpus as r,tmpdir as o}from"node:os";import{join as s,resolve as i}from"node:path";import{fileURLToPath as c}from"node:url";import{Worker as a}from"node:worker_threads";import{importMetaResolve as l}from"resolve-esm";import p from"chalk";const{gray:u}=p;const f=l("#worker");const m=process.platform==="win32";const y=b();const h=r().length;const d=Object.freeze(["--experimental-import-meta-resolve","--no-warnings"]);const w=c(await f);class g{constructor(t){const e=Object.getOwnPropertyDescriptors(t);Object.values(e).forEach((t=>t.writable=false));Object.defineProperties(this,e)}get[Symbol.toStringTag](){return"LinkInfo"}get isAnyLink(){return 0<this.type}get isDirLink(){return!!(this.type&1)}get isFileLink(){return!!(this.type&2)}get isHardLink(){return!!(this.type&16)}get isJunction(){return!!(this.type&8)}get isSoftLink(){return!!(this.type&12)}get isSymLink(){return!!(this.type&4)}}function k(){return y}async function v(t){const e=process.cwd();t={...t};t.noSymlink&&(t.noSymlink=m);t.quiet||(t.quiet=t.silent);const{baseDir:n=".",dryRun:r,entries:o={},force:s,noSymlink:i,quiet:c,silent:l}=t;const p=[];try{process.chdir(n);const t=L(o);const{size:f}=t;if(f<1){c||console.log(u("No valid entries."));return[]}{const t=p.length=Math.min(h,f);const e=!i&&await y;const n={dryRun:r,force:s,preferSymlink:e,quiet:c,silent:l};const o={execArgv:d,workerData:n};for(let e=0;e<t;p[e++]=new a(w,o));}const m=[...t];const g=new Map(m.map((([t])=>[t,null])));const k=S.bind(null,m.reverse(),g);await Promise.all(p.map(k));return[...g.values()]}finally{p.forEach((t=>void t.terminate()));process.chdir(e)}}async function b(){if(!m){return true}const t={force:true,recursive:true};const r=s(o(),(Date.now()+Math.random()).toString(36).padEnd(12,"0"));try{await e(r,t);await n(r+".tmp",r,"file");return true}catch(t){return false}finally{void e(r,t)}}async function S(e,n,r){while(0<e.length){r.postMessage(e.pop());const[o]=await t(r,"message");n.set(o.linkPath,new g(o))}}function L(t){const e=Object.entries(t);const n=new Map;for(const[t,r]of e){const o=i(t);if(n.has(o)){const r=[...n.keys()].indexOf(o);const[s]=e[r];throw new Error(`Duplicate Links: "${s}" == "${t}"`)}n.set(o,r)}return n}export{k as isSymlinkAvailable,v as mklnks};
//# sourceMappingURL=main.js.map
