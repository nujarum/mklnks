import{once as t}from"node:events";import{createRequire as e}from"node:module";import{rm as n,symlink as r}from"node:fs/promises";import{cpus as o,tmpdir as s}from"node:os";import{join as i,resolve as c}from"node:path";import{Worker as a}from"node:worker_threads";import l from"chalk";const{gray:p}=l;const u=process.platform==="win32";const f=e(import.meta.url);const m=v();const h=o().length;const y=Object.freeze(["--experimental-import-meta-resolve","--no-warnings"]);const d=f.resolve("#worker");class g{constructor(t){const e=Object.getOwnPropertyDescriptors(t);Object.values(e).forEach((t=>t.writable=false));Object.defineProperties(this,e)}get[Symbol.toStringTag](){return"LinkInfo"}get isAnyLink(){return 0<this.type}get isDirLink(){return!!(this.type&1)}get isFileLink(){return!!(this.type&2)}get isHardLink(){return!!(this.type&16)}get isJunction(){return!!(this.type&8)}get isSoftLink(){return!!(this.type&12)}get isSymLink(){return!!(this.type&4)}}function w(){return m}async function k(t){const e=process.cwd();t={...t};t.noSymlink&&=u;t.quiet||=t.silent;const{baseDir:n=".",dryRun:r,entries:o={},force:s,noSymlink:i,quiet:c,silent:l}=t;const f=[];try{process.chdir(n);const t=L(o);const{size:e}=t;if(e<1){c||console.log(p("No valid entries."));return[]}{const t=f.length=Math.min(h,e);const n=!i&&await m;const o={dryRun:r,force:s,preferSymlink:n,quiet:c,silent:l};const p={execArgv:y,workerData:o};for(let e=0;e<t;f[e++]=new a(d,p));}const u=[...t];const g=new Map(u.map((([t])=>[t,null])));const w=b.bind(null,u.reverse(),g);await Promise.all(f.map(w));return[...g.values()]}finally{f.forEach((t=>void t.terminate()));process.chdir(e)}}async function v(){if(!u){return true}const t={force:true,recursive:true};const e=i(s(),(Date.now()+Math.random()).toString(36).padEnd(12,"0"));try{await n(e,t);await r(e+".tmp",e,"file");return true}catch(t){return false}finally{void n(e,t)}}async function b(e,n,r){while(0<e.length){r.postMessage(e.pop());const[o]=await t(r,"message");n.set(o.linkPath,new g(o))}}function L(t){const e=Object.entries(t);const n=new Map;for(const[t,r]of e){const o=c(t);if(n.has(o)){const r=[...n.keys()].indexOf(o);const[s]=e[r];throw new Error(`Duplicate Links: "${s}" == "${t}"`)}n.set(o,r)}return n}export{w as isSymlinkAvailable,k as mklnks};
//# sourceMappingURL=main.mjs.map
